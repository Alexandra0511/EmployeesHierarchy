Voicila Alexandra

	Pentru functia "hire" am alocat memorie campurilor angajatului, am cautat nodul managerului cu functia search_node si am adaugat noul angajat in echipa acestuia cu ajutorul functiei "addinTeam". Pentru "fire" am mutat intai echipa angajatului care trebuie concediat in echipa managerului, l-am sters pe acesta din echipa cu functia "del" si i-am eliberat memoria. Funtia de promovare am facut-o asemanator, dar in loc sa sterg angajatul din ierarhie l-am mutat in echipa corespunzatoare managerului cerut cu functiile mai sus implementate. Deasemenea, am reinitializat numarul angajatilor acestuia cu 0. "move_employee" am implementat-o utilizand acelasi principiu. Pentru "move_team", am mutat simplu angajatul fara a rupe legatura cu echipa sa. La functia "fire_team" am folosit functia anterioara de concediere pentru a sterge intai echipa si apoi angajatul din varful echipei.

	Pentru prima functie, am creat un vector cu toti angajatii de sub manager printr-o functie recursiva, avand ca parametru adresa dimensiunii vectorului, pentru a pastra modificarea acestuia. In functia din schelet, am apelat functia dupa ce am alocat memorie contorului, dupa care am utilizat algoritmul bubble sort pentru sortarea vectorului. 	Asemanator pentru functia a doua am creat o functie recursiva pentru creearea vectorului, tinand cont de data aceasta de nivel. Analog, am sortat vectorul si l-am afisat. Pentru gasirea managerului cu cei mai multi angajati, in functia recursiva am analizat 2 cazuri: daca numarul de angajati depasea maximul anterior, actualizam variabila max si suprascriam vectorul. Daca numarul era egal, doar adaugam angajatul in vector, crescand dimesiunea acestuia.

	Parcurgand in lungime arborele, incepand cu nodul angajatului care devine root, am rupt, pe rand, legatura managerilor cu tree-ul, dupa care i-am adaugat in noul arbore, sub managerul trecut si am reactualizat variabilele. Iesind din while, am adaugat manual nodul corespunzator root-ului in noul tree.
